from typing import Annotated, List
from typing_extensions import TypedDict
from langchain_core.messages import HumanMessage, AIMessage, SystemMessage
from langgraph.graph import StateGraph, END
from langgraph.graph.message import add_messages
from langgraph.prebuilt import ToolNode, tools_condition
from langchain.chat_models import init_chat_model
import os

os.environ["AZURE_OPENAI_API_KEY"] =""
os.environ["AZURE_OPENAI_ENDPOINT"] = ""
os.environ["OPENAI_API_VERSION"] = ""

# --- TOOL ---
def mark_attendance(lanid: str, day: str):
    """Mark attendance for an employee for today or yesterday.
    Args:
        lanid: Employee LAN ID (e.g., 'yashu258173').
        day: 'today' or 'yesterday'.
    Returns confirmation string.
    """
    from datetime import datetime, timedelta
    date_str = (datetime.now() if day == "today" else datetime.now() - timedelta(days=1)).strftime("%Y-%m-%d")
    print(f"[TOOL CALLED] Marked attendance for {lanid} on {date_str}")
    return f"Attendance marked for {lanid} on {date_str}."

tools = [mark_attendance]

# --- STATE ---
class State(TypedDict):
    messages: Annotated[List[HumanMessage | AIMessage | SystemMessage], add_messages]

# --- LLM ---
model = init_chat_model(
    "azure_openai:gpt-4o",
    azure_deployment="gpt-4o"  # Use your Azure deployment name if needed!
    # api_key="YOUR_AZURE_KEY",
    # base_url="https://YOUR_RESOURCE.openai.azure.com/",
    # api_version="2024-02-15-preview",
)
model_with_tools = model.bind_tools(tools)

SYSTEM_PROMPT = (
    "You are an EXL Attendance Bot. Your ONLY job is to mark employee attendance for today or yesterday using the mark_attendance tool. "
    "If the user asks for anything else, politely refuse and repeat that you only mark attendance for today or yesterday. "
    "Always use the tool when both lanid and day are provided. If either is missing, ask the user for it. "
    "NEVER answer with text directly. NEVER answer any other type of query."
)

def agent_node(state: State):
    msgs = [SystemMessage(content=SYSTEM_PROMPT)] + state["messages"]
    response = model_with_tools.invoke(msgs)
    return {"messages": [response]}

# --- GRAPH ---
graph_builder = StateGraph(State)
graph_builder.add_node("agent", agent_node)
graph_builder.add_node("tools", ToolNode(tools=tools))
graph_builder.add_conditional_edges(
    "agent",
    tools_condition,
    path_map={"tools": "tools", "end": END, "__end__": END}
)
graph_builder.add_edge("tools", "agent")
graph_builder.set_entry_point("agent")
graph = graph_builder.compile()

# --- MAIN LOOP ---
def main():
    print("=== EXL Attendance REAct Agent ===")
    print("Type 'exit' to quit.\n")
    memory = []
    while True:
        user_input = input("User: ")
        if user_input.lower() in ("exit", "quit", "q"):
            print("Goodbye!")
            break
        memory.append(HumanMessage(content=user_input))
        response_text = ""
        for msg in graph.stream({"messages": memory}):
            if isinstance(msg, dict):
                ai_msg = msg.get("agent", {}).get("messages", [None])[0]
                if ai_msg and hasattr(ai_msg, "content") and ai_msg.content:
                    response_text = ai_msg.content
            elif hasattr(msg, "content") and msg.content:
                response_text = msg.content
        print("Assistant:", response_text)
        memory.append(AIMessage(content=response_text))

if __name__ == "__main__":
    main()
